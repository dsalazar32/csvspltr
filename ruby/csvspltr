#!/usr/bin/env ruby
require 'thor'
require 'csv'
require 'thread'
require 'pry'
require 'benchmark'

class Csvspltr < Thor
  attr_accessor :pager
  desc "splt FILE", "paginates csvs"
  long_desc <<-LONGDESC 
    `csvspltr splt FILE` will split up a csv document into 
     \x5multiple documents based on a limit of (n) rows.
     \x5 
     \x5The default amount of rows is: 1,048,575
  LONGDESC
  def splt(file)
    begin
      # NOTE: Benchmarking different combinations shows
      # that more threads doesn't mean faster...
      puts Benchmark.measure { 
        perpg, pgno, page = 1048575, 1, []
        horizon = perpg
        @runners = Sprntr.new(false, 3)
        File.open(file, "r") do |fbuf|
          fbuf.each do |line|
            pgno = flush_to_file(file, pgno, line, (fbuf.lineno == horizon || fbuf.eof?))
            horizon = perpg * pgno
          end
        end
        @runners.finish!
      }
    rescue Errno::ENOENT => e
      puts "#{e.message}"
    end
  end

  private
  def flush_to_file(fname, pgno, line, flush=false)
    @page ||= {filename: filename(fname, pgno), lines: []}
    @page[:lines] << line
    if flush
      payload = @page
      @runners.run Proc.new { 
        File.open(payload[:filename], "a+") do |fbuf|
          payload[:lines].each do |line|
            fbuf.write(line)
          end
        end
      }
      @page = nil
      return pgno += 1 
    end
    pgno
  end

  def filename(path, idx)
    @fpath ||= filepath(path)
    @fptrn ||= fileptrn(path)
    File.join(@fpath, (@fptrn % idx)).gsub(" ", "_")
  end

  def filepath(path)
    fpath = "#{File.dirname(path)}/paged"
    FileUtils.mkdir_p(fpath) 
    fpath
  end

  def fileptrn(path)
    filename, ext = File.basename(path).split('.')
    "#{filename}_%00004d.#{ext}"
  end

  class Sprntr
    attr_reader :threads, :async, :pool

    def initialize(async=false, cnt=1)
      @async = async
      runners(cnt) if @async
    end

    def run(func)
      @async ? asyncrun(func) : func.call
    end

    def finish!
      return true if !@async
      sleep 1 while !idle?
      idle?
    end

    def idle?
      @pool.num_waiting == @threads.count
    end

    def asyncrun(func)
      @pool.push(func)
    end

    def runners(cnt)
      @pool, @threads = Queue.new, []
      cnt.times do
        @threads << Thread.new(&method(:running))
      end
    end

    def running
      loop do
        callable = @pool.pop
        begin
          callable.call
        rescue Exception => e
          $stderr.puts e.class.name
          $stderr.puts e.message 
        end
      end
    end
  end
end

Csvspltr.start(ARGV)

